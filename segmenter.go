package segmenter

import (
	"errors"
)

// SegmentFunc is like bufio.SplitFunc, but without an error return value
type SegmentFunc func(data []byte, atEOF bool) (start int, end int, err error)

var ErrIncompleteRune = errors.New("incomplete rune")
var ErrIncompleteToken = errors.New("incomplete token")

// AsSplitFunc maps a SegmentFunc to a bufio.SplitFunc, as a convenience
func AsSplitFunc(f SegmentFunc, data []byte, atEOF bool) (advance int, token []byte, err error) {
	if len(data) == 0 {
		return 0, nil, nil
	}

	start, end, err := f(data, atEOF)

	if errors.Is(err, ErrIncompleteRune) && !atEOF {
		// Rune extends past current data, request more
		return 0, nil, nil
	}

	if errors.Is(err, ErrIncompleteToken) && !atEOF {
		// Token extends past current data, request more
		return 0, nil, nil
	}

	return end, data[start:end], err
}

// Segmenter is an iterator for byte arrays
type Segmenter struct {
	f    SegmentFunc
	data []byte

	current  span
	previous *stack

	err error
}

func New(f SegmentFunc) *Segmenter {
	return &Segmenter{
		f:        f,
		previous: &stack{},
	}
}

func (sc *Segmenter) SetText(data []byte) {
	sc.data = data

	sc.current = zero
	sc.previous.clear()
	sc.err = nil
}

// Next advances the Segmenter to the next token. It returns false when there
// are no remaining segments, or an error occurred.
//	text := []byte("This is an example.")
//
//	segment := whitespace.NewSegmenter(text)
//	for segment.Next() {
//		fmt.Printf("%q\n", segment.Bytes())
//	}
//	if err := segment.Err(); err != nil {
//		log.Fatal(err)
//	}
func (seg *Segmenter) Next() bool {
	if seg.current.end == len(seg.data) {
		return false
	}

	start, end, err := seg.f(seg.data[seg.current.end:], true)
	seg.err = err

	if err != nil {
		return false
	}

	if start == end {
		return false
	}

	next := span{
		start: seg.current.end + start,
		end:   seg.current.end + end,
	}

	if seg.current != zero {
		seg.previous.push(seg.current)
	}

	seg.current = next

	return true
}

func (seg *Segmenter) Previous() bool {
	if previous, exists := seg.previous.pop(); exists {
		seg.current = previous
		return true
	}

	return false
}

func (seg *Segmenter) Start() int {
	return seg.current.start
}

func (seg *Segmenter) End() int {
	return seg.current.end
}

func (seg *Segmenter) Err() error {
	return seg.err
}

// Bytes returns the most recent token generated by a call to Scan.
func (seg *Segmenter) Bytes() []byte {
	return seg.data[seg.current.start:seg.current.end]
}
